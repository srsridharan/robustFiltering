function  mainFile
% This is the main rountine where a system simulation is run and the results are fed to a robust filter. The output of the filter
% and the true states/output from the system are then studied via plots that are saved to files.


	clear all;close all;
	clc;
	warning off all; % this turns off messages from the fmin

	% initialize parameters for the simulation
		stopTime = 12;
		numOfValFnQuadratics = 40;
		wsigma = 15*0.0361; 
		vsigma =  15*0.0181;
		xinitial  = [0;pi];
		dt = 0.1;
		numSteps = round(stopTime/dt);
		
		
		% system dynamics (continuous)	
		Ac = [0 0; 1 0];
		Bc = [1; 0];
		% discretize the system dynamics
		Ad = (Ac*dt+ eye(size(Ac)));
		Bd = (Bc*dt);

		% dynamics for the filter
		Atilde = inv(Ac*dt+ eye(size(Ac)));
		Btilde =  - Atilde* Bd;

		outputFnToFit = @outputFn; % this is the output of the system

		s7 = rng;
		save  s7;


		% weighting array on different quadratic terms in the cost function
			simParam = [inv(wsigma*sqrt(dt));inv(sqrt(1)*vsigma);5.011;5.011];
			filterWeightOnMeasNoise = simParam(1);
			Qw = filterWeightOnMeasNoise;
			filterWeightOnDynNoise=  simParam(2);
			R =filterWeightOnDynNoise;
			initialStateCovarEstimate  =  blkdiag([simParam(3)],[simParam(4)]);
			filterWeightOnState =initialStateCovarEstimate ;
			N =filterWeightOnState;
			L =  -xinitial'*N;
			Phi = xinitial'*N*xinitial;
			initialQuadratic= [N L';L Phi];
			initialStateEstimate=  xinitial;
			xhat =initialStateEstimate;
			systemSpecificParam = {Atilde,Btilde};
			filterWeightOnMeasNoise= Qw;

	% create the filter object
			filtObj =codFreeFilterClass(systemSpecificParam,filterWeightOnMeasNoise,filterWeightOnDynNoise, filterWeightOnState, initialStateEstimate, ...
			initialStateCovarEstimate, initialQuadratic,outputFnToFit);


	% generate the process and measurement noise
		wnoise = wsigma*sqrt(dt)*randn(numSteps,1);
		vnoise = vsigma*sqrt(1)* randn(numSteps,1);

	%initialize the simulation states, output vectors
			xtrue = zeros(2,numSteps);
			ytrue = zeros(1,numSteps);
			xhatvec = zeros(2,numSteps);
			xtrue(:,1) = xinitial;
			xhatvec(:,1) = xinitial;

	% now run the simulation and at each step feed the output into the filter to get the updated state estimate
		for(timeCtr = 2:numSteps)
			% generate the quadratic estimates for the output and its squared terms (at the current state)
			filtObj = filtObj.generate_quadapprox_script(xhatvec(:,timeCtr-1) ); 
			
			% generate the state and output at the current time step	
			xtrue(:,timeCtr) = Ad*xtrue(:,timeCtr-1) + Bd*wnoise(timeCtr-1);
			ytrue(timeCtr) = outputFn(xtrue(2,timeCtr)) + vnoise(timeCtr);

			% generate the value function quadratics at the current time step using the current output  
			newSetOfValFnQuadratics = filtObj.generateQuadraticsInNextTimeStep(ytrue(timeCtr));
		
			% prune the quadratics in the expansion of the value function 
			filtObj=filtObj.pruneQuadraticsAndGenerateNewEst(newSetOfValFnQuadratics);

			% set the current state estimate generated by the robust filter
			xhatvec(:,timeCtr) = filtObj.stateEstimate;
		end

	% now plot the results and save them to file 
		t = 0:dt:stopTime-dt;
		fileNameForStatePlot = 'Stateplot8';
		fileNameForMeasurementPlot = 'MeasurementPlot8';
		helperPlotFns(t, xtrue,xhatvec,ytrue,fileNameForStatePlot,fileNameForMeasurementPlot);


end % of function mainFile


function ret = outputFn(x)
% this is the output function for the system
	ret =  x.^3/40;
end


function helperPlotFns(t, xtrue,xhatvec,ytrue,fileNameForStatePlot, fileNameForMeasurementPlot)
 % This function plots the measurement and state estimates and saves the figures to file. 
 % The plotting is done using the 'helperFnPlotter' function. The new figures are generated in this function
 % to facilitate grabbing the handles and storing the figures
	figure;
	axisHandle = subplot(2,1,1) ;
	xDat = t;
	yDatCell{1} = xtrue(1,:);
	datMarkerCell{1} = '--r';
	yDatCell{2}= xhatvec(1,:); 
	datMarkerCell{2} = 'g';
	xLabelToUse = '';
	titleToUse = 'State 1';
	yLabelToUse ='State value';
	legendCell ={'True state';'Estimated state'} ;
	plotlineWidth = 2;
	axisLineWidth = 1;
	legendInterp='none';
	legendBoxState = 'on';

	helperFnPlotter(axisHandle,xDat,yDatCell,datMarkerCell,titleToUse,xLabelToUse, yLabelToUse,legendCell,...
				plotlineWidth,axisLineWidth,legendInterp,legendBoxState);



	axisHandle = subplot(2,1,2);
	xDat = t;
	yDatCell{1} = xtrue(2,:);
	datMarkerCell{1} = '--r';
	yDatCell{2}= xhatvec(2,:); 
	datMarkerCell{2} = 'g';
	xLabelToUse = 'Time (s)';
	titleToUse = 'State 2';
	yLabelToUse ='State value';
	legendCell ={'True state';'Estimated state'} ;
	plotlineWidth = 2;
	axisLineWidth = 1;
	legendInterp='none';
	legendBoxState = 'on';


	helperFnPlotter(axisHandle,xDat,yDatCell,datMarkerCell,titleToUse,xLabelToUse, yLabelToUse,legendCell,...
				plotlineWidth,axisLineWidth,legendInterp,legendBoxState);

	set(gcf, 'PaperPositionMode', 'auto');
	print(gcf,'-depsc2', [fileNameForStatePlot,'.eps']);
	saveas(gcf,[fileNameForStatePlot,'.fig']);




	figure;
	xDat = t;
	yDatCell{1} = ytrue;
	datMarkerCell{1} = '--r';
	yDatCell{2}= outputFn(xhatvec(2,:)); 
	datMarkerCell{2} = 'g';

	yDatCell{3}=outputFn(xtrue(2,:));
	datMarkerCell{3} = '-.b';

	xLabelToUse = 'Time (s)';
	titleToUse = '';
	yLabelToUse ='Output value';
	legendCell ={'Observed process y(t) = $(x_2 (t))^3/40 + v(t) $','Estimated output $(\hat{x}_2(t))^3/40$ ','Output $(x_2 (t))^3/40$'} ;
	plotlineWidth = 2;
	axisLineWidth = 1;
	legendInterp='latex';
	legendBoxState = 'off';

	helperFnPlotter(axisHandle,xDat,yDatCell,datMarkerCell,titleToUse,xLabelToUse, yLabelToUse,...
				legendCell,plotlineWidth,axisLineWidth,legendInterp,legendBoxState);

	set(gcf, 'PaperPositionMode', 'auto');
	print(gcf,'-depsc2', [fileNameForMeasurementPlot,'.eps']);
	saveas(gcf,[fileNameForMeasurementPlot,'.fig']);
end 

function helperFnPlotter(axisHandle,xDat,yDatCell,datMarkerCell,titleToUse,xLabelToUse, yLabelToUse,legendCell,plotlineWidth,axisLineWidth,...
			legendInterp,legendBoxState)
%% this function is generated courtesy of the information obtained at:
		%http://blogs.mathworks.com/loren/2007/12/11/making-pretty-graphs/
	
	for(cel1ctr = 1:length(yDatCell))											
		plot(xDat,yDatCell{cel1ctr},datMarkerCell{cel1ctr},'LineWidth',plotlineWidth);
		hold on;
	end	
	title(titleToUse); grid on;
	hYLabel = ylabel(yLabelToUse);
	hXLabel = xlabel(xLabelToUse);
	hLegend= legend(legendCell);
	set(hLegend,'interpreter', legendInterp);
	set(hLegend,'Box',legendBoxState);



	hTitle = title(titleToUse);
	set(axisHandle, ...
		'LineWidth'       , axisLineWidth         );

	set( axisHandle, ...
			'FontName'   , 'Helvetica' );
	set([hTitle,  hYLabel,hXLabel], ...
			'FontName'   , 'Times');
	set([hLegend, axisHandle]             , ...
			'FontSize'   , 19           );
	set([hYLabel,hXLabel]  , ...
    'FontSize'   , 19          );
	set( hTitle                    , ...
			'FontSize'   , 19          , ...
			'FontWeight' , 'bold'      );

	set(axisHandle, ...
		'Box'         , 'off'     , ...
		'TickDir'     , 'out'     , ...
		'TickLength'  , [.02 .02] , ...
		'XMinorTick'  , 'on'      , ...
		'YMinorTick'  , 'on'      , ...
		'YGrid'       , 'on'      , ...
		'XColor'      , [.3 .3 .3], ...
		'YColor'      , [.3 .3 .3], ...
		'LineWidth'   , axisLineWidth        );

end % of function helperFnPlotter

